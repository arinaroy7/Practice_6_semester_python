Решение системы линейных алгебраических уравнений методом Гаусса

Метод Гаусса состоит из двух этупов: I. Приведение матрицы к треугольному виду с помощью элементарных преобразований - прямой ход. II. Нахождение решений системы путем подстановки значений снизу вверх - обратный ход.

Ход решения:

Импортируем библиотеки python

Используем фукнцию def gauss_elimination(A, b):, которая решает систему линейных уравнений методом Гаусса. Где А - матрица коэффицентов nxn, b - вектор-столбец правой части матрицы, который представляет собой решение системы уравнений.

i - индекс строки. Ведущий элемент находится в A[i][i]. k – индекс строки ниже опорной, который будем обнулять. j – индекс столбца в строке k, который обновляем

np.hstack - функция, которая позволяет объединять элементы массивов в горизонтальное положение.

С помощью функции reshape можно изменять формы существующего массива без изменения данных, которые в нем находятся. Можно изменять количество элементов в каждом измерении.

Находим максимальный по модулю элемент в текущем столбеце для выбора ведущего элемента.
for i in range(n): max_el = abs(A[i][j]) max_row = i for k in range(i+1, n): if abs(A[k][i]) > max_el: max_el =abs(A[k][i]) max_row = k A[[i, max_row]] = A[[max_row, i]]

Предполагаем, что главный элемент находится на главной диагонали и запоминаем его индекс. max_row - возвращает наивысший индекс строки. С помощью цикла for проверяем все элементы ниже главной диагонали. Если элемент больше текущего, запоминаем его, далее меняем строки, чтобы на главной диагонали был маскимальный элемент.

Зануляем элементы под ведущим элементом, вычисляя коэффицент для обнуления. Для каждой строки k, начиная со следующей k+1, вычисляется коэффицент factor = A[k][i] / A[i][i]. Этот коэффициент показывает, какую долю строки i нужно вычесть из строки k, чтобы обнулить элемент A[k][i].

Создаем вектор решений ввиде массива из n элементов np.zeros, в котором будет хранится результат найденных решений.

В цикле «for i in range(n - 1, -1, -1):» переменная i последовательно принимает значения от n–1 до 0 (то есть, цикл идёт в обратном порядке). Это необходимо для обратного хода метода Гаусса, когда начиная с последнего уравнения (с одной неизвестной) вычисляют значение переменной и затем подставляют его в предыдущие уравнения для поиска остальных переменных. n-1 последний индекс массива. -1 означает, что мы уменьшаяем число на 1 каждый раз. Т. е. идем назад. Начиная от самого большого элемента до -1, при этом -1 не входит.

x[i] = A[i][n] / A[i][i] !=0 else 0 - Находим одно из решений матрицы в последней строке делением.

Задаем значения нашей матрицы и вектору b. Выводим исходные данные.

С помощью функции np.linalg.solve решаем систему линейных уравнений вида Ax=b.

Чтобы точно вычислить методом Гаусса матрицу, необходимо посчитать невязку(ошибку). norm_values хранит ошибку (невязку) в каждой размерности. Невязка считается по формуле E=||b-Ax||. np.dot(A, x) - скалярное матричное умножение матрицы А на вектор х. norm_values.append(eps) - добавляем результат невязки в список.

Корректировка значений невязки. Поулчаем длину списка norm_values. Проходимся по всем элементам списка и умножаем на 10^12 степени т.к. невязка может быть очень маленькой 10^(-6). Далее округляем до двух знаков после запятой. Так мы ее масштабируем. pow - функция python для возведении числа в степень.

Строим график зависимости невязки от размерности. plt.plot(n_values, norm_values) - Строим график plt.show() - Отображаем график.

